<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Flashcard Ti·∫øng Anh c·ªßa b√© ƒêan</title>
  <style>
    * { box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
    body {
      margin: 0;
      background: linear-gradient(to bottom right, #e1f5fe, #f1f8e9);
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    h1 { color: #01579b; margin-bottom: 10px; text-align: center; }
    .filters, .form, .controls, .move-form {
      margin: 15px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    select, input, textarea, button {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      font-size: 14px;
    }
    button {
      background: #0288d1;
      color: white;
      cursor: pointer;
    }
    button:hover { background: #0277bd; }
    .flashcard-container {
      width: 420px;
      height: 260px;
      perspective: 1000px;
      margin-bottom: 20px;
      position: relative;
    }
    .flashcard {
      width: 100%;
      height: 100%;
      position: relative;
      transition: transform 0.8s;
      transform-style: preserve-3d;
      cursor: pointer;
    }
    .flashcard-inner {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      padding: 20px;
      text-align: center;
    }
    .front, .back { backface-visibility: hidden; background: #fff; }
    .back { background: #e3f2fd; transform: rotateY(180deg); }
    .flipped { transform: rotateY(180deg); }
    .delete-btn { background: #ef5350; }
    .delete-btn:hover { background: #e53935; }
    .counter { font-size: 16px; color: #555; margin-bottom: 10px; }
    textarea {
      resize: vertical;
      min-height: 100px;
      width: 100%;
      max-width: 600px;
    }
  </style>
</head>
<body>
  <h1>üìò Flashcard Ti·∫øng Anh c·ªßa b√© ƒêan</h1>
  <div class="filters">
    <select id="level-filter" onchange="updateTopicFilter()">
      <option value="">Tr√¨nh ƒë·ªô (T·∫•t c·∫£)</option>
      <option value="B2">B2</option>
      <option value="C1">C1</option>
      <option value="C2">C2</option>
    </select>
    <select id="topic-filter">
      <option value="">Ch·ªß ƒë·ªÅ (T·∫•t c·∫£)</option>
    </select>
  </div>
  <div class="form">
    <input id="front-input" placeholder="T·ª´...">
    <input id="back-input" placeholder="Nghƒ©a...">
    <select id="level-input" onchange="updateTopicOptions()">
      <option value="">Ch·ªçn tr√¨nh ƒë·ªô</option>
      <option value="B2">B2</option>
      <option value="C1">C1</option>
      <option value="C2">C2</option>
    </select>
    <select id="topic-input">
      <option value="">Ch·ªçn ch·ªß ƒë·ªÅ</option>
    </select>
    <input id="new-topic" placeholder="(Ho·∫∑c th√™m ch·ªß ƒë·ªÅ m·ªõi)">
    <button onclick="addCard()">‚ûï Th√™m th·∫ª</button>
  </div>
  <div class="form" style="flex-direction: column; align-items: center;">
    <textarea id="bulk-input" placeholder="apple (n) : qu·∫£ t√°o&#10;computer : m√°y t√≠nh&#10;..."></textarea>
    <button onclick="addBulkCards()">‚ûï Th√™m danh s√°ch</button>
  </div>
  <div class="counter" id="counter"></div>
  <div class="flashcard-container" onclick="flipCard()">
    <div class="flashcard" id="flashcard">
      <div class="flashcard-inner front" id="card-front">T·ª´: Hello</div>
      <div class="flashcard-inner back" id="card-back">Nghƒ©a: Xin ch√†o</div>
    </div>
  </div>
  <div class="controls">
    <button onclick="prevCard()">‚óÄ Tr∆∞·ªõc</button>
    <button onclick="nextCard()">Sau ‚ñ∂</button>
    <button class="delete-btn" onclick="deleteCard()">üóë Xo√°</button>
  </div>
  <div class="move-form">
    <select id="move-level" onchange="updateMoveTopics()">
      <option value="">Chuy·ªÉn sang tr√¨nh ƒë·ªô...</option>
      <option value="B2">B2</option>
      <option value="C1">C1</option>
      <option value="C2">C2</option>
    </select>
    <select id="move-topic">
      <option value="">Ch·ªçn ch·ªß ƒë·ªÅ...</option>
    </select>
    <button onclick="moveCard()">üîÅ Di chuy·ªÉn</button>
  </div>
  <script>
    let allCards = [];
    let topicsByLevel = { B2: [], C1: [], C2: [] };
    let filteredCards = [];
    let current = 0;
    const flashcard = document.getElementById("flashcard");
    const front = document.getElementById("card-front");
    const back = document.getElementById("card-back");
    const counter = document.getElementById("counter");
    const levelInput = document.getElementById("level-input");
    const topicInput = document.getElementById("topic-input");
    const newTopicInput = document.getElementById("new-topic");
    const levelFilter = document.getElementById("level-filter");
    const topicFilter = document.getElementById("topic-filter");

    function saveToStorage() {
      localStorage.setItem("flashcards", JSON.stringify(allCards));
      localStorage.setItem("topicsByLevel", JSON.stringify(topicsByLevel));
    }

    function loadFromStorage() {
      const cards = localStorage.getItem("flashcards");
      const topics = localStorage.getItem("topicsByLevel");
      if (cards) allCards = JSON.parse(cards);
      if (topics) topicsByLevel = JSON.parse(topics);
      updateTopicOptions();
      updateTopicFilter();
      applyFilters();
      updateCard();
    }

    function updateCard() {
      if (filteredCards.length === 0) {
        front.textContent = "Kh√¥ng c√≥ th·∫ª n√†o.";
        back.textContent = "H√£y th√™m flashcard!";
        counter.textContent = "";
        return;
      }
      flashcard.classList.remove("flipped");
      front.textContent = filteredCards[current].front;
      back.textContent = filteredCards[current].back;
      counter.textContent = `Th·∫ª ${current + 1} / ${filteredCards.length}`;
    }

    function flipCard() {
      flashcard.classList.toggle("flipped");
    }
    function nextCard() {
      if (filteredCards.length) {
        current = (current + 1) % filteredCards.length;
        updateCard();
      }
    }
    function prevCard() {
      if (filteredCards.length) {
        current = (current - 1 + filteredCards.length) % filteredCards.length;
        updateCard();
      }
    }

    function addCard() {
      const frontVal = document.getElementById("front-input").value.trim();
      const backVal = document.getElementById("back-input").value.trim();
      const level = levelInput.value;
      let topic = topicInput.value;
      const newTopic = newTopicInput.value.trim();
      if (!frontVal || !backVal || !level) return alert("Nh·∫≠p ƒë·ªß t·ª´, nghƒ©a, tr√¨nh ƒë·ªô!");
      if (newTopic) {
        topic = newTopic;
        if (!topicsByLevel[level].includes(topic)) topicsByLevel[level].push(topic);
      }
      if (!topic) return alert("Ch·ªçn ho·∫∑c nh·∫≠p ch·ªß ƒë·ªÅ!");
      allCards.push({ front: "T·ª´: " + frontVal, back: "Nghƒ©a: " + backVal, level, topic });
      saveToStorage();
      updateTopicOptions();
      applyFilters();
      current = filteredCards.length - 1;
      updateCard();
    }

    function deleteCard() {
      if (filteredCards.length === 0) return;
      const cardToDelete = filteredCards[current];
      allCards = allCards.filter(c => !(c.front === cardToDelete.front && c.back === cardToDelete.back && c.level === cardToDelete.level && c.topic === cardToDelete.topic));
      saveToStorage();
      applyFilters();
      current = Math.max(0, current - 1);
      updateCard();
    }

    function applyFilters() {
      const level = levelFilter.value;
      const topic = topicFilter.value;
      filteredCards = allCards.filter(card => (!level || card.level === level) && (!topic || card.topic === topic));
      current = 0;
      updateCard();
    }

    function updateTopicOptions() {
      const level = levelInput.value;
      topicInput.innerHTML = '<option value="">Ch·ªçn ch·ªß ƒë·ªÅ</option>';
      if (topicsByLevel[level]) {
        topicsByLevel[level].forEach(t => {
          topicInput.innerHTML += `<option value="${t}">${t}</option>`;
        });
      }
    }

    function updateTopicFilter() {
      const level = levelFilter.value;
      topicFilter.innerHTML = '<option value="">Ch·ªß ƒë·ªÅ (T·∫•t c·∫£)</option>';
      if (topicsByLevel[level]) {
        topicsByLevel[level].forEach(t => {
          topicFilter.innerHTML += `<option value="${t}">${t}</option>`;
        });
      }
      applyFilters();
    }

    function addBulkCards() {
      const text = document.getElementById("bulk-input").value.trim();
      const level = levelInput.value;
      let topic = topicInput.value;
      const newTopic = newTopicInput.value.trim();
      if (!level) return alert("H√£y ch·ªçn tr√¨nh ƒë·ªô!");
      if (newTopic) {
        topic = newTopic;
        if (!topicsByLevel[level].includes(topic)) topicsByLevel[level].push(topic);
      }
      if (!topic) return alert("Ch·ªçn ho·∫∑c nh·∫≠p ch·ªß ƒë·ªÅ!");
      const lines = text.split('\n');
      let added = 0;
      for (let line of lines) {
        if (!line.includes(':')) continue;
        const [frontRaw, backRaw] = line.split(':');
        const front = frontRaw.trim();
        const back = backRaw.trim();
        if (front && back) {
          allCards.push({ front: "T·ª´: " + front, back: "Nghƒ©a: " + back, level, topic });
          added++;
        }
      }
      if (added > 0) {
        saveToStorage();
        updateTopicOptions();
        applyFilters();
        current = filteredCards.length - 1;
        updateCard();
        document.getElementById("bulk-input").value = "";
      } else {
        alert("Kh√¥ng th√™m ƒë∆∞·ª£c th·∫ª n√†o. H√£y ki·ªÉm tra ƒë·ªãnh d·∫°ng!");
      }
    }

    function updateMoveTopics() {
      const level = document.getElementById("move-level").value;
      const topicSelect = document.getElementById("move-topic");
      topicSelect.innerHTML = '<option value="">Ch·ªçn ch·ªß ƒë·ªÅ...</option>';
      if (topicsByLevel[level]) {
        topicsByLevel[level].forEach(t => {
          topicSelect.innerHTML += `<option value="${t}">${t}</option>`;
        });
      }
    }

    function moveCard() {
      const newLevel = document.getElementById("move-level").value;
      const newTopic = document.getElementById("move-topic").value;
      if (!filteredCards.length) return;
      if (!newLevel || !newTopic) return alert("Ch·ªçn c·∫£ tr√¨nh ƒë·ªô v√† ch·ªß ƒë·ªÅ m·ªõi!");
      const card = filteredCards[current];
      const i = allCards.findIndex(c => c.front === card.front && c.back === card.back && c.level === card.level && c.topic === card.topic);
      if (i !== -1) {
        allCards[i].level = newLevel;
        allCards[i].topic = newTopic;
        if (!topicsByLevel[newLevel].includes(newTopic)) topicsByLevel[newLevel].push(newTopic);
        saveToStorage();
        applyFilters();
        updateCard();
      }
    }

    levelFilter.addEventListener("change", updateTopicFilter);
    topicFilter.addEventListener("change", applyFilters);
    loadFromStorage();
  </script>
</body>
</html>